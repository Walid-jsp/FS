import { FollowCamera, HemisphericLight, MeshBuilder, Scalar, Scene, SceneLoader, Vector3 } from "@babylonjs/core";
import { Inspector } from "@babylonjs/inspector";
import { KeyboardEventTypes } from "@babylonjs/core";
import meshUrl from "../assets/models/HVGirl.glb";
import { StandardMaterial } from "@babylonjs/core";
import { Color3 } from "@babylonjs/core";
import { ShadowGenerator } from "@babylonjs/core";

const TRACK_WIDHT = 6;
const TRACK_HEIGHT = 0.1;
const TRACK_DEPTH = 3;
const BORDER_HEIGHT = 0.5;
const NB_TRACKS = 50;
const NB_OBSTACLES = 5;
const SPAWN_POS_Z = (TRACK_DEPTH * NB_TRACKS) - 1;

class Game {

    engine;
    canvas;
    scene;
    #player;
    obstacles = [];

    #gameScene;
    #gameCamera;
    #shadowGenerator;

    inputMap = {};
    actions = {};


    constructor(engine, canvas) {
        this.engine = engine;
        this.canvas = canvas;

    }

    init() {
        this.createScene();
        //Inspector.Show(this.scene, {});
    }

    start() {
        this.initGame();
        this.gameLoop();
        this.endGame();
    }

    initGame() {
        this.#gameScene = this.createScene();
        this.#gameScene.attachControl();

        this.initInput();
    }

    initInput() {
        console.log("initInput() exécuté !");
        this.inputMap = {};  // S'assure que la map d'input est bien définie
        console.log("Scene utilisée dans initInput() :", this.#gameScene);
        window.addEventListener("keydown", (event) => {
            console.log("Touche détectée par window :", event.code);
        });

        this.#gameScene.onKeyboardObservable.add((kbInfo) => {
            switch (kbInfo.type) {
                case KeyboardEventTypes.KEYDOWN:
                    console.log("Touche pressée :", kbInfo.event.code); // Vérifie si ça s'affiche dans la console
                    this.inputMap[kbInfo.event.code] = true;
                    break;
                case KeyboardEventTypes.KEYUP:
                    this.inputMap[kbInfo.event.code] = false;
                    this.actions[kbInfo.event.code] = true;
                    break;
            }
        });
    }


    endGame() { };

    gameLoop() {
        this.engine.runRenderLoop(() => {
            this.updateGame();
            this.actions = {};
            this.scene.render();
        });
    }

    updateGame() {

        if (!this.#player) {
            console.warn("Le joueur n'est pas encore chargé...");
            return;
        }
        console.log("updateGame running");
        let delta = this.engine.getDeltaTime() / 1000.0;

        if (this.inputMap["KeyI"]) {
            Inspector.Show(this.scene, {});
        }

        if (this.inputMap["KeyA"]) {
            console.log("clavier marche ")
            this.#player.position.x -= 0.1; // Déplacement à gauche
        } if (this.inputMap["KeyD"]) {
            this.#player.position.x += 0.1; // Déplacement à droite
        }
        if (this.inputMap["KeyW"])
            this.#player.position.z += 0.01;
        if (this.inputMap["KeyS"])
            this.#player.position.z -= 0.01;

        if (!this.#player) return; // On attend que le joueur soit chargé



        this.obstacles.forEach(obstacle => {


            if (this.#player.intersectsMesh(obstacle, false)) {
                console.log("Collision détectée !");


                let material = new StandardMaterial("obstacleMaterial", this.scene);
                material.diffuseColor = new Color3(1, 0, 0); // Rouge
                obstacle.material = material;

                // Faire reculer le joueur
                this.#player.position.z += 0.5; // Avance corrigée en recul
            }
        });


        for (let i = 0; i < this.obstacles.length; i++) {
            let obstacle = this.obstacles[i];
            obstacle.position.z += (50 * delta);

            if (obstacle.position.z >= 1) {
                let x = Scalar.RandomRange(-TRACK_WIDHT / 2, TRACK_WIDHT / 2);
                let z = Scalar.RandomRange(-SPAWN_POS_Z, -(SPAWN_POS_Z - 50));
                obstacle.position.set(x, 0.5, z);
            }
        }
    }

    createScene() {
        const scene = new Scene(this.engine);
        scene.collisionsEnabled = true;

        this.#gameCamera = new FollowCamera("camera1", new Vector3(0, 18, -35),
            scene);
        this.#gameCamera.heightOffset = 18;
        this.#gameCamera.radius = -35;
        this.#gameCamera.maxCameraSpeed = 1;
        this.#gameCamera.cameraAcceleration = 0.025;
        this.#gameCamera.rotationOffset = 0;
        // this.camera = new FreeCamera("camera1", new Vector3(0, 3.8, 5), this.scene);
        // this.camera.setTarget(new Vector3(0, 3, 3));
        // this.camera.attachControl(this.canvas, true);

        this.#shadowGenerator = new ShadowGenerator(1024, sLight);
        this.#shadowGenerator.useBlurExponentialShadowMap = true;

        let light = new HemisphericLight("light", new Vector3(0, 1, 0), this.scene);
        light.intensity = 0.7;

        SceneLoader.ImportMesh("", "", meshUrl, this.scene, (newMeshes) => {
            this.#player = newMeshes[0];
            this.#player.name = "girlCharacter";
            this.#player.scaling = new Vector3(0.1, 0.1, 0.1);
            this.#player.position = new Vector3(0, 0, 0);
            this.camera.target = this.#player;
            console.log("Joueur chargé, démarrage du gameLoop !");

        });


        let mainTrack = MeshBuilder.CreateBox("trackMiddle", { width: TRACK_WIDHT, height: TRACK_HEIGHT, depth: TRACK_DEPTH });
        let leftBorder = MeshBuilder.CreateBox("leftBorder", { width: TRACK_HEIGHT, height: BORDER_HEIGHT, depth: TRACK_DEPTH });
        leftBorder.position.set(-(TRACK_WIDHT / 2), (BORDER_HEIGHT / 2) - (TRACK_HEIGHT / 2), 0);
        leftBorder.parent = mainTrack;

        let rightBorder = MeshBuilder.CreateBox("rightBorder", { width: TRACK_HEIGHT, height: BORDER_HEIGHT, depth: TRACK_DEPTH });
        rightBorder.position.set(TRACK_WIDHT / 2, (BORDER_HEIGHT / 2) - (TRACK_HEIGHT / 2), 0);
        rightBorder.parent = mainTrack;

        for (let i = 1; i <= NB_TRACKS; i++) {
            let newTrack = mainTrack.clone("track2");
            newTrack.position.z = -TRACK_DEPTH * i;
        }

        let obstacleModele = MeshBuilder.CreateCapsule("obstacle", this.scene);
        for (let i = 0; i < NB_OBSTACLES; i++) {
            let obstacle = obstacleModele.clone("obstacle" + i);
            let x = Scalar.RandomRange(-TRACK_WIDHT / 2, TRACK_WIDHT / 2);
            let z = Scalar.RandomRange(-SPAWN_POS_Z, -(SPAWN_POS_Z - 50));
            obstacle.position.set(x, 0.5, z);
            this.obstacles.push(obstacle);
        }
        obstacleModele.dispose();

        return this.scene;
    }
}

export default Game;